# ============================
# Google Colab - Single Cell
# Data Augmentation for Mpox Lesion Images (6 deterministic transforms)
# ============================

# 1) Install dependencies (quiet)
!pip -q install albumentations==1.4.10 opencv-python-headless==4.10.0.84

import os, glob, shutil
import cv2
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import albumentations as A

# ----------------------------
# USER SETTINGS (edit here)
# ----------------------------
INPUT_DIR  = "/content/data/images"         # folder with .jpg/.png (can be class-subfolders too)
OUTPUT_DIR = "/content/data_augmented"      # where augmented images will be saved
KEEP_SUBFOLDERS = True                      # True: preserve class folders under OUTPUT_DIR
COPY_ORIGINALS  = True                      # True: also copy originals to OUTPUT_DIR
EXTENSIONS = (".jpg", ".jpeg", ".png", ".bmp", ".tif", ".tiff")

# Optional: visualize a few samples after processing
VISUALIZE = True
N_VIS = 4                                   # how many original images to visualize (random subset)

# ----------------------------
# Helper functions
# ----------------------------
def list_images(root_dir, exts=EXTENSIONS):
    paths = []
    for p in glob.glob(os.path.join(root_dir, "**", "*"), recursive=True):
        if os.path.isfile(p) and os.path.splitext(p.lower())[1] in exts:
            paths.append(p)
    return sorted(paths)

def ensure_dir(p):
    os.makedirs(p, exist_ok=True)

def rel_subpath(path, base):
    return os.path.relpath(os.path.dirname(path), base)

def read_rgb(path):
    img = cv2.imread(path, cv2.IMREAD_COLOR)
    if img is None:
        raise ValueError(f"Could not read image: {path}")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return img

def write_rgb(path, img_rgb):
    img_bgr = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)
    ensure_dir(os.path.dirname(path))
    ok = cv2.imwrite(path, img_bgr)
    if not ok:
        raise ValueError(f"Could not write image: {path}")

def safe_stem(path):
    b = os.path.basename(path)
    stem, ext = os.path.splitext(b)
    return stem, ext

# ----------------------------
# Define the 6 augmentations
# (deterministic: always the same transformation)
# ----------------------------
# Notes:
# - rotate: +15 degrees (counterclockwise)
# - zoom: scale 1.2x
# - flip: horizontal
# - brightness: +30% (multiply by 1.3)
# - translation: (10,10) pixels
# - contrast: +20% (multiply by 1.2 around mean)
#
# We keep output size equal to original (height, width).

def build_transforms():
    # All transforms use a fixed probability p=1 to apply deterministically.
    # Border is handled with reflection to avoid black corners when possible.
    return {
        "rot15": A.Compose([
            A.Affine(rotate=15, scale=1.0, translate_px={"x": 0, "y": 0},
                     interpolation=cv2.INTER_LINEAR, mode=cv2.BORDER_REFLECT_101, p=1.0)
        ]),
        "zoom12": A.Compose([
            A.Affine(scale=1.2, rotate=0, translate_px={"x": 0, "y": 0},
                     interpolation=cv2.INTER_LINEAR, mode=cv2.BORDER_REFLECT_101, p=1.0)
        ]),
        "hflip": A.Compose([
            A.HorizontalFlip(p=1.0)
        ]),
        "bright30": A.Compose([
            A.RandomBrightnessContrast(brightness_limit=(0.30, 0.30), contrast_limit=(0.0, 0.0), p=1.0)
        ]),
        "trans10": A.Compose([
            A.Affine(translate_px={"x": 10, "y": 10}, rotate=0, scale=1.0,
                     interpolation=cv2.INTER_LINEAR, mode=cv2.BORDER_REFLECT_101, p=1.0)
        ]),
        "contrast20": A.Compose([
            A.RandomBrightnessContrast(brightness_limit=(0.0, 0.0), contrast_limit=(0.20, 0.20), p=1.0)
        ]),
    }

# ----------------------------
# Main processing
# ----------------------------
ensure_dir(OUTPUT_DIR)
transforms = build_transforms()
img_paths = list_images(INPUT_DIR)

if len(img_paths) == 0:
    raise RuntimeError(f"No images found in {INPUT_DIR}. Please upload/copy images there.")

print(f"Found {len(img_paths)} images in: {INPUT_DIR}")
print(f"Output will be saved to: {OUTPUT_DIR}")
print(f"KEEP_SUBFOLDERS={KEEP_SUBFOLDERS}, COPY_ORIGINALS={COPY_ORIGINALS}")

n_written = 0
errors = []

for ip in img_paths:
    try:
        img = read_rgb(ip)
        h, w = img.shape[:2]

        # Determine output subfolder
        sub = rel_subpath(ip, INPUT_DIR) if KEEP_SUBFOLDERS else ""
        out_base = os.path.join(OUTPUT_DIR, sub)

        stem, ext = safe_stem(ip)

        # (Optional) copy original
        if COPY_ORIGINALS:
            out_orig = os.path.join(out_base, f"{stem}{ext}")
            ensure_dir(os.path.dirname(out_orig))
            shutil.copy2(ip, out_orig)
            n_written += 1

        # Apply each augmentation and save
        for tag, tfm in transforms.items():
            aug = tfm(image=img)["image"]

            # Ensure dtype and range (Albumentations usually keeps uint8, but enforce)
            if aug.dtype != np.uint8:
                aug = np.clip(aug, 0, 255).astype(np.uint8)

            out_path = os.path.join(out_base, f"{stem}__{tag}{ext}")
            write_rgb(out_path, aug)
            n_written += 1

    except Exception as e:
        errors.append((ip, str(e)))

print(f"\nDone. Files written: {n_written}")
if errors:
    print(f"Errors: {len(errors)}")
    for p, msg in errors[:10]:
        print(" -", p, "->", msg)
else:
    print("No errors.")

# ----------------------------
# Quick visualization (optional)
# ----------------------------
if VISUALIZE:
    rng = np.random.default_rng(42)
    sample = img_paths if len(img_paths) <= N_VIS else list(rng.choice(img_paths, size=N_VIS, replace=False))

    # For each sample, show original + 6 augs (7 images)
    for ip in sample:
        img = read_rgb(ip)
        stem, ext = safe_stem(ip)
        sub = rel_subpath(ip, INPUT_DIR) if KEEP_SUBFOLDERS else ""
        out_base = os.path.join(OUTPUT_DIR, sub)

        # Load from disk to ensure what was saved
        paths_to_show = []
        if COPY_ORIGINALS:
            paths_to_show.append(os.path.join(out_base, f"{stem}{ext}"))
        else:
            paths_to_show.append(ip)

        for tag in transforms.keys():
            paths_to_show.append(os.path.join(out_base, f"{stem}__{tag}{ext}"))

        imgs = []
        titles = []
        for p in paths_to_show:
            try:
                imgs.append(read_rgb(p))
                titles.append(os.path.basename(p))
            except Exception:
                continue

        cols = 4
        rows = int(np.ceil(len(imgs) / cols))
        plt.figure(figsize=(4.5 * cols, 4.0 * rows))
        for i, (im, t) in enumerate(zip(imgs, titles), start=1):
            plt.subplot(rows, cols, i)
            plt.imshow(im)
            plt.title(t, fontsize=9)
            plt.axis("off")
        plt.suptitle(f"Augmentations for: {os.path.basename(ip)}", fontsize=12)
        plt.tight_layout()
        plt.show()
